#include <Arduino.h>
#include <WiFiClientSecure.h>
#include <HTTPClient.h>
#include <Arduinojson.h>
#include "cloud.h"

const char* WRITE_KEY = "HUP6GESQWYBLJ05A";
const char* WRITE_URL = "https://api.thingspeak.com/update";
const char* READ_LAST_FEED_URL = 
  "https://api.thingspeak.com/channels/2868636/feeds.json?api_key=YX9DJ58EM9T27MJS&results=1";

//ThingSpeak Certificate
const char* THINGSPEAK_ROOT_CA = R"EOF(
-----BEGIN CERTIFICATE-----
MIIEyDCCA7CgAwIBAgIQDPW9BitWAvR6uFAsI8zwZjANBgkqhkiG9w0BAQsFADBh
MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3
d3cuZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBH
MjAeFw0yMTAzMzAwMDAwMDBaFw0zMTAzMjkyMzU5NTlaMFkxCzAJBgNVBAYTAlVT
MRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxMzAxBgNVBAMTKkRpZ2lDZXJ0IEdsb2Jh
bCBHMiBUTFMgUlNBIFNIQTI1NiAyMDIwIENBMTCCASIwDQYJKoZIhvcNAQEBBQAD
ggEPADCCAQoCggEBAMz3EGJPprtjb+2QUlbFbSd7ehJWivH0+dbn4Y+9lavyYEEV
cNsSAPonCrVXOFt9slGTcZUOakGUWzUb+nv6u8W+JDD+Vu/E832X4xT1FE3LpxDy
FuqrIvAxIhFhaZAmunjZlx/jfWardUSVc8is/+9dCopZQ+GssjoP80j812s3wWPc
3kbW20X+fSP9kOhRBx5Ro1/tSUZUfyyIxfQTnJcVPAPooTncaQwywa8WV0yUR0J8
osicfebUTVSvQpmowQTCd5zWSOTOEeAqgJnwQ3DPP3Zr0UxJqyRewg2C/Uaoq2yT
zGJSQnWS+Jr6Xl6ysGHlHx+5fwmY6D36g39HaaECAwEAAaOCAYIwggF+MBIGA1Ud
EwEB/wQIMAYBAf8CAQAwHQYDVR0OBBYEFHSFgMBmx9833s+9KTeqAx2+7c0XMB8G
A1UdIwQYMBaAFE4iVCAYlebjbuYP+vq5Eu0GF485MA4GA1UdDwEB/wQEAwIBhjAd
BgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwdgYIKwYBBQUHAQEEajBoMCQG
CCsGAQUFBzABhhhodHRwOi8vb2NzcC5kaWdpY2VydC5jb20wQAYIKwYBBQUHMAKG
NGh0dHA6Ly9jYWNlcnRzLmRpZ2ljZXJ0LmNvbS9EaWdpQ2VydEdsb2JhbFJvb3RH
Mi5jcnQwQgYDVR0fBDswOTA3oDWgM4YxaHR0cDovL2NybDMuZGlnaWNlcnQuY29t
L0RpZ2lDZXJ0R2xvYmFsUm9vdEcyLmNybDA9BgNVHSAENjA0MAsGCWCGSAGG/WwC
ATAHBgVngQwBATAIBgZngQwBAgEwCAYGZ4EMAQICMAgGBmeBDAECAzANBgkqhkiG
9w0BAQsFAAOCAQEAkPFwyyiXaZd8dP3A+iZ7U6utzWX9upwGnIrXWkOH7U1MVl+t
wcW1BSAuWdH/SvWgKtiwla3JLko716f2b4gp/DA/JIS7w7d7kwcsr4drdjPtAFVS
slme5LnQ89/nD/7d+MS5EHKBCQRfz5eeLjJ1js+aWNJXMX43AYGyZm0pGrFmCW3R
bpD0ufovARTFXFZkAdl9h6g4U5+LXUZtXMYnhIHUfoyMo5tS58aI7Dd8KvvwVVo4
chDYABPPTHPbqjc1qCmBaZx2vN4Ye5DUys/vZwP9BFohFrH/6j/f3IL16/RZkiMN
JCqVJUzKoZHm1Lesh3Sz8W2jmdv51b2EQJ8HmA==
-----END CERTIFICATE-----
)EOF";

// Maximum number of consecutive network errors and the related variable
const int MAX_HTML_ERRORS = 10;
int html_errors = 0;

// Get control mode integer value from control mode string
int get_control_mode_int(char control_mode[])
{
    int control_mode_int = 0;

    if (!strcmp(control_mode, "on"))
        control_mode_int = 1;
    else if (!strcmp(control_mode, "temp_auto"))
        control_mode_int = 2;
    else if (!strcmp(control_mode, "hum_auto"))
        control_mode_int = 3;

    return control_mode_int;
}

// Get control mode string from control mode integer value
void get_control_mode_str(int control_mode_int, char control_mode[])
{
    if (control_mode_int == 1)
        strcpy(control_mode, "on");
    else if (control_mode_int == 2)
        strcpy(control_mode, "temp_auto");
    else if (control_mode_int == 3)
        strcpy(control_mode, "hum_auto");
    else
        strcpy(control_mode, "off");
}

// Read ThinkSpeak control parameters. It assumes that all control paramenters are written in the same feed.
// It returns true when control parameters have been correctly read. 
bool read_cloud(char control_mode[], float &temp_setpoint, float &hum_setpoint)
{
    //Load certificate
    WiFiClientSecure client;
    client.setCACert(THINGSPEAK_ROOT_CA);
    
    //Start secure connection
    HTTPClient http;
    http.begin(client, READ_LAST_FEED_URL);
    
    bool return_value = true;

    int code = http.GET();

    if (code > 0)
    {
		String payload = http.getString();
		
        Serial.println("\nFrom ThingSpeak");

        // JSON document
        JsonDocument doc;
        deserializeJson(doc, payload);

        // If the feed is correct
        if (!doc["feeds"][0].isNull())
        {
            int source = (int)doc["feeds"][0]["field7"];
            // If the feed comes from a remote computer
            if (!doc["feeds"][0]["field7"].isNull() and source == REMOTE_SOURCE)
            {
				temp_setpoint = doc["feeds"][0]["field3"];
                hum_setpoint = doc["feeds"][0]["field4"];
                get_control_mode_str(doc["feeds"][0]["field6"], control_mode);

                Serial.println("Control mode updated from remote source\n");

                Serial.printf("\tControl mode: %d (%s)\n", get_control_mode_int(control_mode), control_mode);
                Serial.printf("\tTemperature setpoint: %.1f\n", temp_setpoint);
                Serial.printf("\tHumidity setpoint: %.1f\n", hum_setpoint);
            
            }
            else
            {
                Serial.printf("\tThe last feed was generated by the board\n");
                return_value = false;
            }
        }
        else
        {        
            Serial.printf("\tNo feeds available\n");
            return_value = false;
        }       
    }
    else
    {   
		html_errors++;
        if (html_errors >= MAX_HTML_ERRORS) {
            Serial.println("Max HTTP retries reached. Restarting ESP32..."); 
            ESP.restart();
        }
      	Serial.printf("ThingSpeak read request failed. Error code: %d\n\n", code);    
        return_value = false;
    }      
    http.end();;

    return return_value;
}

// Write temperature, humidity, control state, setpoints and control mode into ThinkSpeak channel
void write_cloud(float temp, float hum, int control_state, char control_mode[], float temp_setpoint, float hum_setpoint)
{
    WiFiClientSecure client;
    client.setCACert(THINGSPEAK_ROOT_CA); 
    
    HTTPClient http;
    http.begin(client, WRITE_URL);
    
    http.addHeader("Content-Type", "application/x-www-form-urlencoded");
    String args = "api_key=" + String(WRITE_KEY) + "&field1=" + String(temp) + "&field2=" + String(hum) +
                  "&field3=" + String(temp_setpoint) + "&field4=" + String(hum_setpoint) +
                  "&field5=" + String(control_state) + "&field6=" + String(get_control_mode_int(control_mode)) +
                  "&field7=" + String(BOARD_SOURCE);

    int code = http.POST(args);
    if (code > 0)
    {
		String payload = http.getString();
		Serial.println("\nTo ThingSpeak");
        Serial.printf("Response: %s\n", payload.c_str());
        if (!payload.compareTo("0"))
            Serial.printf("\tThingSpeak error. Can not write\n");
        else
        {
            Serial.printf("\tTemperature: %2.1f\n", temp);
            Serial.printf("\tHumidity: %2.1f\n", hum);
            Serial.printf("\tControl state: %d (%s)\n", control_state, (control_state == 1) ? "on" : "off");
            Serial.printf("\tControl mode: %d (%s)\n", get_control_mode_int(control_mode), control_mode);
            Serial.printf("\tTemperature setpoint: %2.1f\n", temp_setpoint);
            Serial.printf("\tHumidity setpoint: %2.0f\n", hum_setpoint);
        }
    }
    else
    {
		html_errors++;
        if (html_errors >= MAX_HTML_ERRORS) {
            Serial.println("Max HTTP retries reached. Restarting ESP32...");
            ESP.restart();
        }
        Serial.printf("ThingSpeak write request failed. Error code: %d\n\n", code);
    }

    http.end();
}
