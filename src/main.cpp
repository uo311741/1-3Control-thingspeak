#include <arduino.h>
#include <EEPROM.h>
#include <WiFi.h>
#include <ESPmDNS.h>
#include <WiFiClient.h>
#include <WebServer.h>
#include "hal.h"
#include "webhandle.h"
#include "control.h"
#include <esp_system.h>
#include <cloud.h>
#include <ArduinoJson.h>

// Write down your UO here
const char *UO = "311741";

// SSID prefix and password as an access point
const char *SSID_PREFIX = "SEU"; 
const char *PASSWORD    = "12345678"; 

// Default device name
const char DEFAULT_NAME[] = "controlseu";

// Start running as access point
int run_mode = RUN_AS_AP; 

// Maximuum bouncing time of the push button in ms
#define MAX_BOUNCING_TIME 100

// Minimum pressing time to recover factory defaults in ms
#define MIN_FACTORY_TIME 5000

// Web server on TCP port 80
WebServer server(80);

// The push button interrupt service routine sets these variables to true after 
// pressing for a short or long time 
bool restart = false;
bool invalidate_eeprom = false;

// EEPROM factory defaults
eeprom_params_t factory_default_params;

// Variable to store the last time in milliseconds
unsigned long previousMillis = 0;  
// Sampling interval of 5 seconds
const long interval = 5000;

// Set factory defaults parameters
void setFactoryDefaults(eeprom_params_t &params)
{
  params.validation_code = 0xAABBCCDD;
  params.ssid_sta[0] = '\0';
  params.password_sta[0] = '\0';
  strcpy(params.name, DEFAULT_NAME);
  params.temp_setpoint = 20.0; 
  params.hum_setpoint = 60.0;
  strcpy(params.control_mode, CONTROL_MODE_OFF);
}

///////////////////////////////////////////////////////////////////////////////
// Run as access point with a web server for getting SSID, password and device 
// name parameters.
// The SSID of the access point is given by SSID_PREFIX and the UO
///////////////////////////////////////////////////////////////////////////////
void configure_as_ap_webserver()
{
  // Get the SSID as access point. For example, SEU-2A3F125D
  char ssid_ap[32];
  sprintf(ssid_ap, "%s-%s", SSID_PREFIX, UO);

  // Set up WiFi interface as access point
  Serial.printf("Setting AP with SSID: %s", ssid_ap);
  Serial.printf(WiFi.softAP(ssid_ap, PASSWORD) ? " -> OK;" : " ->Failed");
  Serial.printf("  IP address: %s\n", WiFi.softAPIP().toString().c_str());
  
  // Start the mDNS service
  if (MDNS.begin(eeprom_params.name)) 
    Serial.printf("mDNS service started with name %s\n", eeprom_params.name);

  // Start the web server
  server.on("/index.html", handleRoot_ap);
  server.onNotFound(handleNotFound);
  server.begin();
  Serial.printf("Web server started\n");
}

///////////////////////////////////////////////////////////////////////////////
// Try to connect to an access point. Return true when it is connected
///////////////////////////////////////////////////////////////////////////////
bool wifi_connection(const char ssid[], const char password[])
{
    const unsigned MAX_WIFI_RETRIES = 10;
    unsigned wifi_attempts = 0;

    WiFi.mode(WIFI_STA);
    WiFi.begin(ssid, password);
    Serial.printf("\nConnecting to %s ", ssid);

    while (WiFi.status() != WL_CONNECTED && wifi_attempts < MAX_WIFI_RETRIES)
    {
        setStatusLed(ON);
        delay(500);
        setStatusLed(OFF);
        delay(500);
        Serial.print(".");
        wifi_attempts++;
    }

    if (WiFi.status() != WL_CONNECTED)
    {
        Serial.println("\nWiFi connection failed.");
        return false;
    }

    Serial.printf("\nConnected with IP Address: %s\n\n", WiFi.localIP().toString().c_str());
    return true;
}



///////////////////////////////////////////////////////////////////////////////
// ISR for the push button.
// If the push button is pressed for a short time (less than MIN_FACTORY_TIME)
// global variable restart is set. If the push button is pressed for a 
// long time (higher than MIN_FACTORY_TIME) global variable recover_factory is set.
// It assumes a released default state for the push button. 
// In addtion, is assumes that interrupts are generated by pressing or releasing
// the push button.
// Bouncing is considered to last MAX_BOUNCING_TIME ms at most.
///////////////////////////////////////////////////////////////////////////////
void IRAM_ATTR reset_button_isr()
{
  static bool wait_for_press = true; // True if waiting for a push button press
  static unsigned long int push_time = 0; // Time at the push button press
  static unsigned long int prev_int_time = 0; // Time at the previous interrupt
  unsigned long int curr_time = millis();  // Get the current time

  // If waiting for a push button press
  if (wait_for_press)
  {
    // We are waiting for a button press
    if (digitalRead(PUSH_BUTTON_PIN) != LOW)
      return;

    // Ignore any press until MAX_BOUNCING_TIME is elapsed from the previous interrupt
    if (curr_time - prev_int_time > MAX_BOUNCING_TIME)
    {
      push_time = curr_time; // We need this time to calculate the elapsed time afterwards
      prev_int_time = curr_time;
      wait_for_press = false; // Next we are waiting for a push button release
    }
  } 
  // If waiting for a push button release
  else
  {
    // Ignore any release until MAX_BOUNCING_TIME is elapsed from the previous press
    if (curr_time - prev_int_time > MAX_BOUNCING_TIME)
    {
      if ((curr_time - push_time) > MIN_FACTORY_TIME)
        invalidate_eeprom = true;
      else
        restart = true;
      wait_for_press = true; // We are waiting for a new push button press
    }
  }
}

///////////////////////////////////////////////////////////////////////////////
// Arduino setup fuction
///////////////////////////////////////////////////////////////////////////////
void setup()
{
  // Configure the serial port
  Serial.begin(115200);
  delay(1000);
  
  // Initialize the sensor
  initTempHumiditySensor();

  // Set factory defaults and initialize the EEPROM
  setFactoryDefaults(factory_default_params);
  if (!EEPROM.begin(sizeof(eeprom_params_t)))
    Serial.printf("Failed initializing EEPROM\n");

  // Read parameters from EEPROM
  EEPROM.readBytes(0, &eeprom_params, sizeof(eeprom_params));

  // If parameters are invalid
  if (eeprom_params.validation_code != factory_default_params.validation_code)
  {
    setFactoryDefaults(eeprom_params);

    // Set up run mode as access point and run the web server
    run_mode = RUN_AS_AP;
    configure_as_ap_webserver();
  }
  // If parameters are valid
  else
  {
    // Print parameters and set up run mode as station
    Serial.printf("Stored SSID: %s;\tpassword: %s;\tName: %s\n", 
      eeprom_params.ssid_sta, eeprom_params.password_sta, eeprom_params.name);
    run_mode = RUN_AS_STA;
  }

  // Install reset_button_isr() as push button interrupt routine, fired by push button pin changes
  pinMode(PUSH_BUTTON_PIN, INPUT);
  attachInterrupt(PUSH_BUTTON_PIN, reset_button_isr, CHANGE);
 
  // Read web pages from the file system for the given run mode
  cache_web_content(run_mode);  
}

// Management of wifi errors
unsigned int wifi_reconnect_attempts = 0;
const unsigned MAX_WIFI_RECONNECT_ATTEMPTS = 3;
bool has_ever_connected = false; 
const unsigned MAX_WIFI_RETRIES = 10;
unsigned wifi_attempts = 0;

///////////////////////////////////////////////////////////////////////////////
// Arduino loop function
///////////////////////////////////////////////////////////////////////////////
void loop() {
  unsigned long currentMillis = millis();

  if (restart) {
    Serial.println("\nRestarting in 2 seconds...");
    delay(2000);
    ESP.restart();
  }

  if (invalidate_eeprom) {
    eeprom_params.validation_code = factory_default_params.validation_code + 1;
    EEPROM.writeBytes(0, &eeprom_params, sizeof(eeprom_params));
    EEPROM.commit();

    Serial.println("\nInvalidating EEPROM and restarting as AP in 2 seconds...");
    delay(2000);
    ESP.restart();
  }

  if (run_mode == RUN_AS_AP) {
    if ((millis() / 500) % 2)
      setStatusLed(ON);
    else
      setStatusLed(OFF);

    server.handleClient();
  }
  else { // RUN_AS_STA
    if (WiFi.status() != WL_CONNECTED) {
      Serial.println("\nAttempting connection...");

      wifi_attempts = 0;
      if (WiFi.status() == WL_CONNECTED) {
        WiFi.disconnect();
        delay(1000);
    }
      WiFi.begin(eeprom_params.ssid_sta, eeprom_params.password_sta);
      
      while (WiFi.status() != WL_CONNECTED && wifi_attempts < MAX_WIFI_RETRIES) {
        WiFi.reconnect();
        Serial.print(".");
        delay(500);
        wifi_attempts++;
      }

      if (WiFi.status() == WL_CONNECTED) {
        Serial.printf("\nConnected with IP address: %s\n", WiFi.localIP().toString().c_str());
        wifi_reconnect_attempts = 0;

        if (MDNS.begin(eeprom_params.name))
          Serial.printf("mDNS service started with name %s\n", eeprom_params.name);

        server.on("/index.html", handleRoot_sta);
        server.onNotFound(handleNotFound);
        server.begin();
        Serial.println("Web server started");

        has_ever_connected = true;
      }
      else {
        wifi_reconnect_attempts++;
        
        if (wifi_reconnect_attempts >= MAX_WIFI_RECONNECT_ATTEMPTS) {
          Serial.println("\nMax WiFi reconnection attempts reached. Invalidating EEPROM and restarting as AP...");
          eeprom_params.validation_code = factory_default_params.validation_code + 1;
          EEPROM.writeBytes(0, &eeprom_params, sizeof(eeprom_params));
          EEPROM.commit();
          delay(2000);
          ESP.restart();
        }
      }
    }
    else {
      wifi_attempts = 0; 
      wifi_reconnect_attempts = 0; 
      has_ever_connected = true;
      server.handleClient();
    }

    // Sampling each 5 seconds
    if (currentMillis - previousMillis >= interval) {
      previousMillis = currentMillis;

      if (WiFi.status() == WL_CONNECTED) {
        if (read_cloud(eeprom_params.control_mode, eeprom_params.temp_setpoint, eeprom_params.hum_setpoint)) {
          Serial.println("Parameters added from remote updated from ThingSpeak.");
          EEPROM.writeBytes(0, &eeprom_params, sizeof(eeprom_params));
          EEPROM.commit();

          has_ever_connected = true; 
        } else {
          Serial.println("No remote update detected.");
        }
      }

      control_temp_hum();

      if (WiFi.status() == WL_CONNECTED) {
        write_cloud(temp, hum, control_state, eeprom_params.control_mode, eeprom_params.temp_setpoint, eeprom_params.hum_setpoint);
      }
      else if (has_ever_connected) {
        //Temporary mode when the connection is lost
        Serial.println("\nWiFi lost. Temporary mode activated (local sensor readings):");
        Serial.printf("\tTemperature: %2.1f\n", temp);
        Serial.printf("\tHumidity: %2.1f\n", hum);
        Serial.printf("\tControl state: %d (%s)\n", control_state, (control_state == 1) ? "on" : "off");
        Serial.printf("\tControl mode: %s\n", eeprom_params.control_mode);
        Serial.printf("\tTemperature setpoint: %.1f\n", eeprom_params.temp_setpoint);
        Serial.printf("\tHumidity setpoint: %.1f\n", eeprom_params.hum_setpoint);
      }
    }
  }
}
